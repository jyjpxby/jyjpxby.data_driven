## Energy analysis of nanozyme-catalyzed reactions
## matlab_TDEBD_0

clearvars
close all
%Read data
A=load('TDEBD_0_A.txt');
x=A(:,1);y=A(:,2);z=A(:,3);
W=load('TDEBD_W.txt');
xx=W(:,1);yy=W(:,2);zz=W(:,3);
scatter3(x,y,z)%scatter diagram
figure
[X,Y,Z]=griddata(x,y,z,linspace(min(x),max(x))',linspace(min(y),max(y)),'v4');%interpolation
pcolor(X,Y,Z);shading interp%False-color graph
figure,contourf(X,Y,Z) %contour map
figure,surf(X,Y,Z);%3D surface
figure,meshc(X,Y,Z)%profile map
view(0,0); 
figure,meshc(X,Y,Z);%s3 D surface (light color) + contours
hidden off;
figure,contourf(X,Y,Z,20)%Plot the contour lines
[U,V] = gradient(Z,-0.1,-0.1);%Computed gradient
 hold on
 quiver(X,Y,U,V,2,'r')%Gradient diagram
 hold on
 scatter3(xx,yy,zz,'MarkerEdgeColor','k','MarkerFaceColor',[0 .5 .5])
 hold on
% ['H2O2','H2O2','OOH','H2O','O2','H2O2','OH','O2','O2-','H2O2','OOH','H2O','O2-','H2O2','OOH','OH','O2','H2O2','OH','H2O','O2-']);
 hold off
 
 ## matlab_TDEBD_1
 
 clearvars
close all
%Read data
A=load('TDEBD_1_A.txt');
x=A(:,1);y=A(:,2);z=A(:,3);
W=load('TDEBD_W.txt');
xx=W(:,1);yy=W(:,2);zz=W(:,3);
scatter3(x,y,z)%scatter diagram
figure
[X,Y,Z]=griddata(x,y,z,linspace(min(x),max(x))',linspace(min(y),max(y)),'v4');%interpolation
pcolor(X,Y,Z);shading interp%False-color graph
figure,contourf(X,Y,Z) %contour map
figure,surf(X,Y,Z);%3D surface
figure,meshc(X,Y,Z)%profile map
view(0,0); 
figure,meshc(X,Y,Z);%s3 D surface (light color) + contours
hidden off;
figure,contourf(X,Y,Z,20)%Plot the contour lines
[U,V] = gradient(Z,-0.1,-0.1);%Computed gradient
 hold on
 quiver(X,Y,U,V,2,'r')%Gradient diagram
 hold on
 scatter3(xx,yy,zz,'MarkerEdgeColor','k','MarkerFaceColor',[0 .5 .5])
 hold on
% ['H2O2','H2O2','OOH','H2O','O2','H2O2','OH','O2','O2-','H2O2','OOH','H2O','O2-','H2O2','OOH','OH','O2','H2O2','OH','H2O','O2-']);
 hold off
 
 ## matlab_RRTStar_3D
  
  clearvars
close all
data1=importdata('steer3d_O.txt');
data2=data1.data;
x_min = data2(1,1);
y_min = data2(1,2);
z_min = data2(1,3);
x_max = data2(1,4)-x_min;
y_max = data2(1,5)-y_min;
z_max = data2(1,6)-z_min;

A=load('steer3d_A.txt');
x1=A(:,1);y1=A(:,2);z1=A(:,3);
x1=x1-x_min;
y1=y1-y_min;
z1=z1-z_min;
[X1,Y1,Z1]=griddata(x1,y1,z1,linspace(min(x1),max(x1),201)',linspace(min(y1),max(y1),201),'v4');%interpolation
XA=X1;YA=Y1;ZA=Z1;
xa=XA';
XA=xa(:);
ya=YA';
YA=ya(:);
za=ZA';
ZA=za(:);
B=load('steer3d_B.txt');
x2=B(:,1);y2=B(:,2);z2=B(:,3);
x2=x2-x_min;
y2=y2-y_min;
z2=z2-z_min;
[X2,Y2,Z2]=griddata(x2,y2,z2,linspace(min(x2),max(x2),201)',linspace(min(y2),max(y2),201),'v4');%interpolation
XB=X2;YB=Y2;ZB=Z2;
xb=XB';
XB=xb(:);
yb=YB';
YB=yb(:);
zb=ZB';
ZB=zb(:);
XX=[XA;XB];
YY=[YA;YB];
ZZ=[ZA;ZB];
obstacle = [XX,YY,ZZ];
W=[200	198.7622486	500
231.6760636	400	500
200	301.9082001	500
168.3239364	400	500
102.5115325	333.7802991	500
400	230.6343476	500
297.4884675	230.6343476	500
380.4202973	291.2841671	500
297.4884675	333.7802991	500
297.4884675	7.32896E-14	500
357.7652486	147.1892728	500
260.2767811	115.3171738	500
357.7652486	44.0433213	500
42.23475141	44.0433213	500
102.5115325	7.32896E-14	500
200	31.87209902	500
139.7232189	115.3171738	500
19.57970272	291.2841671	500
-7.28388E-14	230.6343476	500
42.23475141	147.1892728	500
102.5115325	230.6343476	500
];
xxx=W(:,1);yyy=W(:,2);zzz=W(:,3);
xxx=xxx-x_min;
yyy=yyy-y_min;
zzz=zzz-z_min;
EPS = data2(1,7);
numNodes = data2(1,8);        
q_start.coord = [data2(1,9)-x_min data2(1,10)-y_min data2(1,11)-z_min];
q_start.cost = 0;
q_start.parent = 0;
q_goal.coord = [data2(1,12)-x_min data2(1,13)-y_min data2(1,14)-z_min];
q_goal.cost = 0;
nodes(1) = q_start;
figure(1)
axis([0 x_max 0 y_max 0 z_max])
surf(X1,Y1,Z1,EdgeColor = 'none')
hold on
scatter3(xxx,yyy,zzz,'MarkerEdgeColor','k','MarkerFaceColor',[0 .5 .5])
hold on
%surf(X2,Y2,Z2,'FaceAlpha',0.5,EdgeColor = 'none')
hold on

for i = 1:1:numNodes
    q_rand = [rand(1)*x_max rand(1)*y_max rand(1)*z_max];
    plot3(q_rand(1), q_rand(2), q_rand(3), 'x', 'Color',  [0 0.4470 0.7410])
    
    % Break if goal node is already reached
    for j = 1:1:length(nodes)
        if nodes(j).coord == q_goal.coord
            break
        end
    end
    
    % Pick the closest node from existing list to branch out from
    ndist = [];
    for j = 1:1:length(nodes)
        n = nodes(j);
        tmp = dist_3d(n.coord, q_rand);
        ndist = [ndist tmp];
    end
    [val, idx] = min(ndist);
    q_near = nodes(idx);
    rr = ones(402,402);
    rr = rr*8;
    q_new.coord = steer3d(q_rand, q_near.coord, val, EPS);
      if checkPath3(q_rand, q_near.coord, obstacle,rr)
          line([q_near.coord(1), q_new.coord(1)], [q_near.coord(2), q_new.coord(2)], [q_near.coord(3), q_new.coord(3)], 'Color', 'k', 'LineWidth', 4);
          drawnow
          hold on
          q_new.cost = dist_3d(q_new.coord, q_near.coord) + q_near.cost;
    
           % Within a radius of r, find all existing nodes
          q_nearest = [];
          r = 5;
          neighbor_count = 1;
          for j = 1:1:length(nodes)
              if checkPath3(nodes(j).coord, q_new.coord, obstacle,rr) && (dist_3d(nodes(j).coord, q_new.coord)) <= r
                  q_nearest(neighbor_count).coord = nodes(j).coord;
                  q_nearest(neighbor_count).cost = nodes(j).cost;
                  neighbor_count = neighbor_count+1;
              end
          end
    
    % Initialize cost to currently known value
    q_min = q_near;
    C_min = q_new.cost;
    
    % Iterate through all nearest neighbors to find alternate lower
    % cost paths
    
    for k = 1:1:length(q_nearest)
        if checkPath3(q_nearest(k).coord, q_new.coord, obstacle,rr) && q_nearest(k).cost + dist_3d(q_nearest(k).coord, q_new.coord) < C_min
            q_min = q_nearest(k);
            C_min = q_nearest(k).cost + dist_3d(q_nearest(k).coord, q_new.coord);
            line([q_min.coord(1), q_new.coord(1)], [q_min.coord(2), q_new.coord(2)], [q_min.coord(3), q_new.coord(3)], 'Color', 'g');            
            hold on
        end
    end
    
    % Update parent to least cost-from node
    for j = 1:1:length(nodes)
        if nodes(j).coord == q_min.coord
            q_new.parent = j;
        end
    end
    
    % Append to nodes
    nodes = [nodes q_new];
      end
end

D = [];
for j = 1:1:length(nodes)
    tmpdist = dist_3d(nodes(j).coord, q_goal.coord);
    D = [D tmpdist];
end

% Search backwards from goal to start to find the optimal least cost path
[val, idx] = min(D);
q_final = nodes(idx);
q_goal.parent = idx;
q_end = q_goal;
nodes = [nodes q_goal];
while q_end.parent ~= 0
    start = q_end.parent;
    line([q_end.coord(1), nodes(start).coord(1)], [q_end.coord(2), nodes(start).coord(2)], [q_end.coord(3), nodes(start).coord(3)], 'Color', 'r', 'LineWidth', 4);
    hold on
    q_end = nodes(start);
end

 ## matlab_steer3d
 
 function A = steer3d(qr, qn, val, eps)
data1=importdata('steer3d_O.txt');
data2=data1.data;
x_min = data2(1,1);
y_min = data2(1,2);
z_min = data2(1,3);
   qnew = [data2(1,12)-x_min data2(1,13)-y_min];
   if val >= eps
       qnew(1) = qn(1) + ((qr(1)-qn(1))*eps)/dist_3d(qr,qn);
       qnew(2) = qn(2) + ((qr(2)-qn(2))*eps)/dist_3d(qr,qn);
       qnew(3) = qn(3) + ((qr(3)-qn(3))*eps)/dist_3d(qr,qn);
   else
       qnew(1) = qr(1);
       qnew(2) = qr(2);
       qnew(3) = qr(3);
   end
   
   A = [qnew(1), qnew(2), qnew(3)];
end

## matlab_dist_3d

function d = dist_3d(q1,q2)
    d = sqrt((q1(1)-q2(1))^2 + (q1(2)-q2(2))^2 + (q1(3)-q2(3))^2);
end

## matlab_checkPath3

%% checkPath3.m

function feasible=checkPath3(n,newPos,circleCenter,r)

feasible=true;

movingVec = [newPos(1)-n(1),newPos(2)-n(2),newPos(3)-n(3)];

movingVec = movingVec/sqrt(sum(movingVec.^2)); %unitization

for R=0:0.5:sqrt(sum((n-newPos).^2))

posCheck=n + R .* movingVec;

if ~(feasiblePoint3(ceil(posCheck),circleCenter,r) && feasiblePoint3(floor(posCheck),circleCenter,r))

feasible=false;break;

end

end

if ~feasiblePoint3(newPos,circleCenter,r), feasible=false; end

end

function h=distanceCost3(a,b) %% distanceCost.m

h = sqrt(sum((a-b).^2, 2));

end

%% feasiblePoint3.m

function feasible=feasiblePoint3(point,circleCenter,r)

feasible=true;

% check if collission-free spot and inside maps

for row = 1:length(circleCenter(:,1))

if sqrt(sum((circleCenter(row,:)-point).^2)) <= r(row)

feasible = false;break;

end

end

end
